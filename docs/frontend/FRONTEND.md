
## Фронтенд

Конфигурация находится в файле [`extension.config.js`](../../extension.config.js)

### Инициализация приложения:
Html с настройкой входной точки в js приложение описывалось в разделе [backend/controllers](../backend/CONTROLLERS.md)

```php
<<<HTML
<div id="$moduleId"></div>
<script>
    require(['$pathToFrontendEntrypoint'], function (main) {
        main.default($params);
    });
</script>
HTML;
```

Входной скрипт [`index.js`](../../src/frontend/index.js) в нем происходит только экспорт главного компонента приложения:
```JS
export { default } from './components/App/App';
```

[`react-compat.js`](../../src/frontend/react-compat.js) нужен для совместимости имен react и библиотеки @plesk/ui-library

### Структура приложения
Структура приложения построена на компонентах. Чем меньше компонент и чем меньше он берет на себя ответственности тем лучше.
Все компоненты находятся в папке [`src/frontend/components`](../../src/frontend/components) и разбиты по папкам по назначению.
Например `App` - главный компонент приложения, `Header` - компонент шапки, `Footer` - компонент подвала, `Page` - компонент страницы, `Form` - компонент формы, `Table` - компонент таблицы и т.д.
Если в компоненте Header есть вложенный компонент `Logo` то он должен находится в папке `Header` и называться `Logo.js`. Структура может быть более сложной, но вложенность не должна быть больше 2 уровней.

Начнем с самого главного компонента приложения [`App.js`](../../src/frontend/components/App/App.js) в нем происходит инициализация приложения и рендеринг главного компонента.
Компоненты приложения должны быть функциональными, т.е. не иметь состояния и не использовать методы жизненного цикла. Все данные должны приходить извне в виде пропсов.
Обычно компонент это функция, которая принимает пропсы и возвращает jsx.
```JS
const App = (props) => {
    return (
        <div>
            <Header />
            <Page />
            <Footer />
        </div>
    );
};
```
Пропсы можно типизировать с помощью библиотеки `prop-types`:
```JS
import PropTypes from 'prop-types';
App.propTypes = {
    title: PropTypes.string.isRequired,
};
```
Что означает что компонент принимает обязательный пропс `title` типа `string`.
Компонент App из примера выше не имеет состояния и не использует методы жизненного цикла, поэтому его можно написать в виде стрелочной функции.
[`App.js`](../../src/frontend/components/App/App.js) внутри себя имеет компонент AppProvider, который отвечает за контекст компонента. Об этом написано ниже.
В компонент провайдер передается еще один провайдер для использования компонента Toaster, который отвечает за отображение всплывающих сообщений.
И уже на самом последнем уровне передаем компонент [Credentials.js](../../src/frontend/pages/Credentials.js) который является главным компонентом страницы авторизации.
Я специально поместил компонент со страницей авторизации в папку pages, т.к. это не просто компонент, а страница приложения.

Рассмотрим более сложный компонент [`Form.js`](../../src/frontend/components/Form/Form.js) в нем используется хук `useState` для хранения состояния формы.
```JS
const [form, setForm] = useState({
    apiKey: '',
    keyTitle: credentials.keyTitle,
});
```
Хук useState принимает в качестве аргумента начальное состояние формы, в данном случае это пустой объект. Возвращает массив из двух элементов, первый это текущее состояние, второй это функция для изменения состояния. Его нужно использовать всегда вместо прямого изменения состояния, чтобы реакт мог отслеживать изменения и перерисовывать компонент.

Хук useEffect это хук для использования методов жизненного цикла. В данном случае он используется для получения данных из localStorage и установки их в состояние формы. Его еще можно назвать computed свойством (как во Vuejs), т.к. он будет вызываться при каждом изменении состояния формы.
```JS
useEffect(() => {
    return () => {
        effect
    };
}, [input]);
```

### Состояние приложения
В небольших приложениях для передачи состояния и параметров можно использовать [контексты](https://reactjs.org/docs/context.html)

В skeleton для передачи глобального состояния и управления Toaster использовались контексты.

Как это работает:
- создаем папку с компонентом
- в ней создаем файл Context.js. Внутри себя она содержит следующее:
```js
import React, { useContext } from 'react';
export const Context = React.createContext();
export const useSome = () => useContext(Context);
```
(для работы с контекстом мы далее будем вызывать хук useSome)
- создаем файл Provider.js. Внутри себя он содержит следующее:
```js
import React, { useState, createElement } from 'react';
import { Context } from './Context';

const Provider = (params) => {
    const [state, setState] = useState();
    return (
        <Context.Provider value={{ ...params, state, setState }}>
            {children}
        </Context.Provider>
    );
}

export default Provider;
```
тут `params` это параметры которые можно передать в компонент
внутри себя провайдер должен хранить состояния компонента и управлять им. 
Наружу провайдер отдает на чтение нужные параметры, состояние, а так же может отдавать методы для управления состоянием. 
- затем создаем сам компонент, где через хук `useSome`  мы можем получать состояние нашего компонента.
- затем оборачиваем родительский код:
```js
<SomePorvider foo={}></SomePorvider>
```
Передаем ему нужные параметры и если нужно вложенные в него теги(комопоненты)
- и теперь на любой вложенности мы можем вызвать хук `useSome` и менять и читать состояние компонента Some.
